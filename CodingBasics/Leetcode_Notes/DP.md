# 动态规划

## DP概念和思想

### DP的问题以及求解步骤

#### 适用DP的问题

- DP适用于重叠子问题和最优子结构性质的问题

  - 最优子结构
    - 局部最优解能决定全局最优解
  - 重叠子问题
    - 在问题的不同部分中反复解决相同的子问题

- DP问题一般是多阶段决策问题

  - 将复杂问题分解为相对简单的子问题

  - 且这些子问题是前后相关的，处理方法相似
    - 前面的子问题的结果记录为“状态”并存储
      - 后面的子问题可以直接查找前面的存储结构





#### DP问题分类

- 线性DP: 顺推、逆推
- 非线性DP： 树形DP



#### 经典DP问题

- 斐波那契数列问题
- 最长公共子序列
- 贝尔曼-福特最短路径
- 编辑距离问题
- 矩阵链称法





### DP和分治的差别

- 分治：子问题是独立的
- DP：子问题前后相关





## 求解步骤

- 定义状态
  - 状态往往就是问题的解
  - 动态规划保存子问题的解（也就是状态），避免重复计算
- 状态转移
  - 常常是子问题之间的联系
- 算法实现



## 动态规划（DP）方法

- 自上而下的方法（记忆化memorization）

- 自下而上的方法（列表法 tabulation）

- | **维度**       | **记忆化 (Memoization - 自顶向下)**                          | **制表法 (Tabulation - 自底向上)**                           |
  | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | **核心思路**   | **递归**。从最终问题开始，通过递归解决子问题并缓存结果。     | **迭代**。从最小的子问题开始，逐步填表直到解决最终问题。     |
  | **状态转移**   | **容易理解**。逻辑通常直接遵循问题的数学定义或递归公式。     | **较难思考**。需要预先理清子问题的计算顺序（拓扑排序）。     |
  | **代码实现**   | **易于编写**。通常只需在现有的递归代码中加入缓存（查找表）即可。 | **逻辑复杂**。当边界条件或约束较多时，嵌套循环的逻辑会变得冗繁。 |
  | **速度/性能**  | **较慢**。存在大量的递归函数调用栈（Stack）开销。            | **较快**。直接通过迭代填充表格，没有递归的额外开销。         |
  | **子问题求解** | **按需求解**。如果某些子问题不需要解决，它会跳过，只计算必要的部分。 | **全量求解**。必须按顺序计算所有子问题，即使某些子问题对最终结果无贡献。 |
  | **表格条目**   | **按需填充**。查找表中的条目不一定全部填满，仅填充被访问到的状态。 | **逐一填充**。从第一个条目（初始状态）开始，所有条目都会被顺序填满。 |

- ##### 例子1：钢条切割最大利益化

  - 题目： 给定一根长度为 **n 英寸**的杆子和一个数组 **price[]** 。 **price[i]**  表示长度为 i 的**一段杆子**的价格 。任务是确定**将杆子切割**并出售各段杆子所能获得的**最大**价值 。
  - 自顶向下的方法
    - $$dp[n] = \max(price[i-1] + dp[n-i])$$​
      - price[i]部分不再进行切割
      - dp[n-i]部分也许还要进行切割
  - 自下向上的方法
    - dp[0]=0
    - dp[1]=price[1]
    - dp[2]=max(dp[1]*2, price[2])
    - dp[3]=max(3*dp[1], dp[2]+dp[1], price[3])
      -  `3 * dp[1]` 已经被包含在 `dp[1] + dp[2]` 里面了，因为 `dp[2]` 本身就考虑过是否要拆成两个 `dp[1]`
    - dp[4]=max(dp[3]+dp[1], 2dp[2], 4dp[1]，price[4])
      - `4dp[1]`也被包含了

- ##### 例子2： 斐波那契数列

  - 传统的递归算法（自顶向下，但是没有记忆化）：导致重复的计算

    - 比如fib(5)=fib(3)+fib(4)
    - fib(3)=fib(2)+fib(1)
    - fib(4)=fib(3)+fib(2)
      - 在这里面，fib(3), fib(2)都被重复计算了

  - 记忆化方法

    - ```c++
      #include <iostream>
      #include <vector>
      using namespace std;
      
      int fibRec(int n, vector<int> &memo) {
        
          // Base case
          if (n <= 1) {
              return n;
          }
      
          // To check if output already exists
          if (memo[n] != -1) {
              return memo[n];
          }
      
          // Calculate and save output for future use
          memo[n] = fibRec(n - 1, memo) + fibRec(n - 2, memo);
      
          return memo[n];
      }
      
      int fib(int n) {
          vector<int> memo(n + 1, -1);
          return fibRec(n, memo);
      }
      
      int main() {
          int n = 5;
          cout << fib(n);
          return 0;
      }
      ```

    - | **步骤**    | **动作**                           | **意义**                                   |
      | ----------- | ---------------------------------- | ------------------------------------------ |
      | **1. 检查** | `if memo[n] != -1: return memo[n]` | **查字典**。如果算过，直接跳过计算。       |
      | **2. 计算** | `res = price[i] + solve(n-i)`      | **去干活**。只有没记录时才真正干活。       |
      | **3. 存储** | `memo[n] = res`                    | **记账**。把辛苦算出的结果存起来供以后用。 |







## 常见的技巧和直觉

- 涉及总量的（注意这个总量未必是问题的总量
- 涉及相邻元素，以及相邻元素问题的关系（状态转移
- 



