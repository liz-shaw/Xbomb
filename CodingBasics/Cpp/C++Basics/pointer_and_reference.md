#  指针

## 基础定义：指针 vs 引用

| **特性**     | **指针 (Pointer)**      | **引用 (Reference)**         |
| ------------ | ----------------------- | ---------------------------- |
| **语法**     | `dataType *ptr = &var;` | `dataType &ref = var;`       |
| **本质**     | 存储内存地址的变量      | 变量的**别名**（同一块内存） |
| **初始化**   | 可以不初始化（不推荐）  | **必须**在声明时初始化       |
| **修改指向** | 可以随时指向其他变量    | 一旦初始化，**不可更改**指向 |
| **空值**     | 可以为 `nullptr`        | **不能为空**                 |

------

## 指针基础操作

### 核心操作符

| **符号** | **名称**     | **作用**                             | **示例** |
| -------- | ------------ | ------------------------------------ | -------- |
| **`&`**  | **取地址符** | 获取变量在内存中的真实地址           | `&var`   |
| **`\*`** | **解引用符** | 访问指针所指向的地址里的具体**数值** | `*ptr`   |

- 关于指针容易被混淆的概念

    | **表达式** | **含义**           | **读作**             |
    | ---------- | ------------------ | -------------------- |
    | `p`        | 指针变量本身       | “p 存储的**地址**”   |
    | `*p`       | 指针指向的内容     | “p **指向的值**”     |
    | `&p`       | 指针变量自己的地址 | “指针**自己的位置**” |


------

### 基本使用流程

1. **定义与初始化**：让指针指向某个地址。

```c++
int var = 10;
int *ptr = &var; // ptr 存储了 var 的内存地址
```

2. **解引用读写**：通过指针操作变量。

```c++
int val = *ptr;  // 读：将 ptr 指向的值（10）赋给 val
*ptr = 20;       // 写：通过 ptr 将 var 的值改为 20
```

3. **空指针检查**

```c++
int *p = nullptr; // 声明时初始化为空，防止“野指针”
if (p != nullptr) { ... } // 使用前检查
```

------

### 指针的算术运算 (Pointer Arithmetic)

- **`ptr++`**：指针向后移动一个**单位**（偏移量 = `sizeof(dataType)`）。
- **示例**：如果 `int` 占 4 字节，`ptr++` 实际上让地址增加了 4。

------



## 函数指针 (Function Pointer)

用于存储并调用函数。

- **语法：** `返回类型 (*指针名)(参数列表) = 函数名;`

- **示例：**

  C++

  ```c++
  int add(int a, int b)
  {
    return a + b;
  }
  
  int main()
  {
    int (*funcptr) (int, int) = add; // Pointer 'funcptr' now points to the functions 'add'
    funcptr(4, 5); // Return 9
  }
  ```

------

## Const 指针

判断技巧：**看 `const` 在 `\*` 的左边还是右边。**

#### ① 常量指针 (Constant Pointer)

- **写法：** `int* const ptr = &x;`
- **特点：** 指针本身是常量，**地址不可改变**。
- ✅ 可以修改值 (`*ptr = 15`)
- ❌ 不可修改指向 (`ptr = &y`)

#### ② 指向常量的指针 (Pointer to Constant)

- **写法：** `const int* ptr = &x;`
- **特点：** 视指向内容为常量，**内容禁改**。
- ✅ 可以修改指向 (`ptr = &y`)
- ❌ 不可修改值 (`*ptr = 15`)

#### ③ 指向常量的常量指针 (Constant Pointer to Constant)

- **写法：** `const int* const ptr = &x;`
- **特点：** 地址和内容**全部锁定**。
- ❌ 不可修改值
- ❌ 不可修改指向

------

### 💡 经验法则 (Summary Table)

| **声明方式**           | **改变指向 (Pointer)?** | **改变数值 (Value)?** | **记忆点**             |
| ---------------------- | ----------------------- | --------------------- | ---------------------- |
| `int* const ptr`       | ❌                       | ✅                     | **常量指针**：地址固定 |
| `const int* ptr`       | ✅                       | ❌                     | **指向常量**：值固定   |
| `const int* const ptr` | ❌                       | ❌                     | **全锁定**             |

## 多级指针 (Pointers to Pointers)

有时候需要存储一个“指针变量”的地址，这就是二级指针（甚至多级）。

- **语法**：`dataType **pptr;`

- **理解**：

  - `ptr` 存的是变量的地址。
  - `pptr` 存的是指针 `ptr` 的地址。

- **示例1：二维数组**

  ```C++
  int rows = 3, cols = 4;
  // 1. 分配一个指针数组（行指针）
  int** matrix = new int*[rows];
  
  // 2. 为每一行分配具体的列空间
  for(int i = 0; i < rows; ++i) {
      matrix[i] = new int[cols];
  }
  
  // 访问方式：matrix[1][2] = 10;
  ```

- **示例2：命令行参数**

  - 在 `main` 函数中： `int main(int argc, char** argv)`

    - `argv` 就是一个二级指针。
    - 它指向一个数组，数组里的每个元素都是一个 `char*`（字符串），代表你从命令行输入的参数。

  - ```c++
    #include <iostream>
    
    int main(int argc, char** argv) {
        // argc: 参数的数量（Argument Count）
        // argv: 指向参数字符串数组的指针（Argument Vector）
    
        std::cout << "收到参数个数: " << argc << std::endl;
    
        for (int i = 0; i < argc; ++i) {
            // argv[i] 是一个 char*，代表第 i 个字符串
            std::cout << "第 " << i << " 个参数是: " << argv[i] << std::endl;
        }
    
        return 0;
    }
    
    """
    argv (二级指针)：指向一个在内存中连续存放的“指针数组”。
    
    argv[0] (一级指针)：存储的是字符串 "./program" 的首地址。
    
    argv[1] (一级指针)：存储的是字符串 "hello" 的首地址。
    
    argv[2] (一级指针)：存储的是字符串 "world" 的首地址。
    
    argv[3]：通常是一个 nullptr，标记数组结束。
        
    """
    
    ```

    



##  指针与数组 (Pointers vs. Arrays)

数组名在大多数情况下会“退化”为指向首元素的指针，但它们并不完全等同。

- **核心区别**：

  - **数组名是常量指针**：你不能执行 `arr++`，因为数组的首地址是固定的。
  - **`sizeof` 不同**：`sizeof(arr)` 返回整个数组的大小；`sizeof(ptr)` 只返回指针本身的大小（通常 4 或 8 字节）。

- **指针访问数组**：

  ```C++
  int arr[3] = {10, 20, 30};
  int *p = arr;
  // *(p + 1) 等同于 arr[1] (20)
  ```

##  动态内存管理 (Dynamic Memory)

指针是操作“堆（Heap）”内存的唯一工具。

- **申请与释放**：

  - `new`：在堆上分配空间并返回地址。
  - `delete`：释放该空间，防止**内存泄漏**。

- **示例**：

  ```C++
  int *p = new int(5); // 动态分配一个 int
  delete p;            // 用完必须手动删除
  p = nullptr;         // 养成好习惯：删除后置空
  ```

## 现代 C++：智能指针 (Smart Pointers)

在现代 C++ (C++11及以后) 中，为了安全，我们**尽量不直接使用 `new/delete`**，而是使用智能指针来自动管理内存。

| **种类**              | **说明**   | **特点**                                                     |
| --------------------- | ---------- | ------------------------------------------------------------ |
| **`std::unique_ptr`** | 独占所有权 | **最常用**。同一时间只能有一个指针指向该对象，不可复制，只能移动。 |
| **`std::shared_ptr`** | 共享所有权 | 多个指针指向同一对象，内部有计数器，计数归零时自动释放。     |
| **`std::weak_ptr`**   | 弱引用     | 配合 `shared_ptr` 使用，防止循环引用导致内存无法释放。       |

# 引用&

## 核心定义与本质

引用是变量的**别名**。它在底层通常被编译器实现为**常量指针**（`Type * const`），但在语法层面上，它就是原变量本身。

- **语法**：`dataType &ref = existingVariable;`
- **三大铁律**：
  1. **必须初始化**：`int &ref;` 是非法代码。
  2. **不可变性**：一旦绑定到一个变量，这辈子都不能改嫁给别人。
  3. **非空性**：它必须引用一个真实存在的内存位置，不能像指针那样设为 `nullptr`。
- **指针和引用的选择**
  - 如果你需要“重新指向”或者“可能为空”，用**指针**。
  - 如果你只需要一个“别名”且确定它永远有效，用**引用**（语法更清爽）。

------

## 引用作为函数参数 (Pass by Reference)

这是引用最强大的用途，解决了指针语法的繁琐，同时保留了性能。

- **修改原值**：函数内部的操作直接反映在实参上（如 `swap` 函数）。
- **避免拷贝**：**传递 `std::string` 或 `std::vector` 等大型对象时，不产生副本，极大地节省 CPU 和内存。**

```c++
void updateString(std::string &s) {
    s += " updated"; // 直接修改外部字符串
}
```

------

##  基于范围的 for 循环

- [ ] 这部分没怎么搞懂auto配合引用的遍历

面对 `std::vector<std::string> vec`，有四种选择：

| **循环写法**        | **发生拷贝？** | **修改原图？** | **性能**   | **最佳实践 (Best Practice)**                       |
| ------------------- | -------------- | -------------- | ---------- | -------------------------------------------------- |
| `auto x`            | ✅ 是           | ❌ 否           | 🐌 低       | 仅当你**确实需要**一份本地副本进行**修改**时使用。 |
| `auto &x`           | ❌ 否           | ✅ 是           | 🚀 高       | 当你需要**原地修改**容器里的每一个元素时使用。     |
| **`auto const &x`** | ❌ 否           | ❌ 否           | 🚀 **最高** | **默认首选**。既安全（只读）又高效（无拷贝）。     |
| `const auto x`      | ✅ 是           | ❌ 否           | 🐌 低       | 很少用。得到一个不可修改的副本（保护副本不被改）。 |

```c++
std::vector<std::string> stooges {"xyz", "abc", "def"};

// Read-only, no copies
for (auto const &str : stooges)
    std::cout << str << std::endl;

// Makes a copy of each string
for (auto str : stooges)
    std::cout << str << std::endl;

// Direct reference, can modify original elements
for (auto &str : stooges)
    str += "!";

// Makes a copy of each string, but prevents modification of the copy
for (const auto str : stooges)
    std::cout << str << std::endl;
```





------



## 经验法则 (Rule of Thumb)

- **大对象**（String/Vector/Class）：**永远**用引用 (`const auto&` 或 `auto&`)。
- **小对象**（int/char/bool/double）：直接用值 (`auto`) 往往更快，因为指针跳转可能比拷贝 4 字节更贵。
- **意图明确**：如果你不打算改数据，务必加上 `const`，这能让代码更安全，也方便编译器优化。

------





